<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | Mark Daggett's Blog]]></title>
  <link href="http://heavysixer.github.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://heavysixer.github.com/"/>
  <updated>2013-02-24T13:22:27-06:00</updated>
  <id>http://heavysixer.github.com/</id>
  <author>
    <name><![CDATA[Mark Daggett]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript Jigs]]></title>
    <link href="http://heavysixer.github.com/blog/2013/02/18/javascript-jigs/"/>
    <updated>2013-02-18T09:06:00-06:00</updated>
    <id>http://heavysixer.github.com/blog/2013/02/18/javascript-jigs</id>
    <content type="html"><![CDATA[<p>In the excellent book "The Pragmatic Programmer: From Journeyman to Master" Hunt and Thomas use the metaphor of a wood worker's jig to describe
how a smart programmer reduces the repetitive nature of coding by creating reusable templates or code generators:</p>

<pre><code>"When woodworkers are faced with the task of producing the same thing over and over, they cheat. They build themselves a jig or a template.
If they get the jig right once, they can reproduce a piece of work time after time. The jig takes away complexity and reduces the chances
of making mistakes, leaving the craftsman free to concentrate on quality."
</code></pre>

<p>To be a jig the solution is highly specific and good for one task, for example making a complex cut. At first you might
want to conflate jigs and design patterns together, because they are both reusable solutions to a problem. Jigs are precise where design
patterns are generalized. While Hunt and Thomas said jigs are generators, I will use them in the context of helpers, friendly little functions
or classes that do one thing well. Many of the most popular JavaScript libraries started as a collection of jigs. Prototype and JQuery for
example, were initially just a collection of reusable snippets that acted like speed-boosts, and shortcuts for discrete problems.</p>

<p>What follows are a collection of jigs that are useful in modern JavaScript applications.</p>

<p>Self Executing Functions
~~~~~~~~~~~~~~~~~~~~~~~~</p>

<p>The immediately invoked function expression (IIFE) is one jig you will see various libraries and frameworks use repeatedly. In its most basic form it can be
written in a couple of ways</p>

<p>.. code-block:: javascript</p>

<p>  ;(function(){</p>

<pre><code>  ...
</code></pre>

<p>  })();</p>

<p>  ;!function(){</p>

<pre><code>  ...
</code></pre>

<p>  }();</p>

<p>  ;-function(){</p>

<pre><code>  ...
</code></pre>

<p>  }();</p>

<p>  ;+function(){</p>

<pre><code>  ...
</code></pre>

<p>  }();</p>

<p>  ;~function(){</p>

<pre><code>  ...
</code></pre>

<p>  }();</p>

<p>  // Not Recommended
  ;void function(){</p>

<pre><code>  ...
</code></pre>

<p>  }();</p>

<p>  // Not Recommended
  ;delete function(){</p>

<pre><code>  ...
</code></pre>

<p>  }();</p>

<p>The beauty of the IIFE is that it uses a unary expression to coerce a function declaration, which would normally need to be explicitly called
into a function expression that can self-execute. Behind the scenes JavaScript is running a unary operation on the function declaration, the
result of that operation is the function expression, which is immediately invoked with the trailing parentheses "()". Besides being elegant code
the IIFE also affords the following:</p>

<ul>
<li>It provides a closure which prevents naming conflicts</li>
<li>It provides elegant block scoping</li>
<li>It prevents pollution of the global namespace.</li>
<li>It promotes the developer to think in terms of modular code.</li>
</ul>


<p>One other point worth mentioning is the use of the semicolon prepending the statement. Adding this provides a bit of defensive programming
against other malformed modules that might have a trailing semicolon. If this were just a function declaration it would be absorbed into the
preceding module. This can often occur when multiple scripts are concatenated together as part of a deploy process. It is highly recommended
that you follow this convention to protect yourself against mystery bugs in production.</p>

<p>Modules
~~~~~~~</p>

<p>Modules are very common is many programming languages, though JavaScript doesn't have a native representation for them. As such other developers
have developed a spec for encapsulating your code inside a reusable module. The following code is based off an example in the "Principles of
Writing Consistent, Idiomatic JavaScript" [1]_.</p>

<p>There are a couple of elements that should be called out in this jig:</p>

<ul>
<li>We see two different examples of the self executing function jig being used. This is to ensure proper closure around the module itself and the
initializer function that adds it to the global namespace.</li>
<li>Invoking this function returns an object with a bound reference to the private variable "data". This allows the developer to enforce
the use of getters and setters for access to the data variable.</li>
</ul>


<p>.. code-block:: javascript</p>

<p>  ;!function(global) {</p>

<pre><code>var Module = (function() {

  // Mostly Private Variable
  var data = 'secret';

  return {

    bool: true,
    string: 'a string',
    array: [1, 2, 3, 4],
    object: {
      lang: "en-Us"
    },
    getData: function() {
      return data;
    },
    setData: function(value) {
      return (data = value);
    }
  };
})();

// expose our module to the global object
global.Module = Module;
</code></pre>

<p>  }(this);</p>

<p>safeEval
~~~~~~~~</p>

<p>The eval function and its siblings setTimeout, setInterval and Function all have access to the JavaScript compiler, which means it is a bit
like running with scissors. Since eval typically does more harm than good people try to work around it as much as possible. This jig does just
that giving you eval like features without calling the function.</p>

<p>.. code-block:: javascript</p>

<p>  // A string representation of an a object similar to what you might get with JSON.
  var dataString = '{"foo":"bar"}';</p>

<p>  ;!function(global, data){</p>

<pre><code>  // the variable name provided is replaced with the evaluated code.
  global[data] = new Function("return" + global[data])() 
</code></pre>

<p>  }(this, "dataString");</p>

<p>  // dataString is now Object {foo: "bar"}</p>

<p>PubSub
~~~~~~</p>

<p>PubSub is short for a publish-subscribe message system, where objects ask to receive messages that are broadcast by publishers. The main
advantage of PubSub is that the subscribers are loosely coupled allowing just about any object to publish and subscribe to messages. PubSub
systems also have been proven to scale much nicer that tightly coupled client / server paradigms. This implementation of PubSub was written
by Ben Alman and can be download from his Github account [2]_. Let's take a look at this jig in detail. Again, the first thing you should
notice is that this jig uses the IIFE jig too (see a pattern yet?). This jig does depend on jQuery for access to the "on","off", and "trigger"
functions. This jig stores an internal list of subscribers as keys of the internal object "o". When a message is broadcast all the subscribers
have the arguments supplied by the publisher transferred to them.</p>

<p>.. code-block:: javascript</p>

<p>  ;(function($) {</p>

<pre><code>var o = $({});

$.subscribe = function() {
  o.on.apply(o, arguments);
};

$.unsubscribe = function() {
  o.off.apply(o, arguments);
};

$.publish = function() {
  o.trigger.apply(o, arguments);
};
</code></pre>

<p>  }(jQuery));</p>

<p>  // Usage Examples
  // Creates a "named" logging function.</p>

<p>  function createLogger(name) {</p>

<pre><code>return function(event, a, b) {

  // Skip the first argument (event object) but log the name and other args.
  console.log(name, a, b);
};
</code></pre>

<p>  }</p>

<p>  // Subscribe to the "foo" topic (bind to the "foo" event, no namespace).
  $.subscribe('foo', createLogger('foo'));</p>

<p>  // Subscribe to the "foo.bar" topic (bind to the "foo" event, "bar" namespace).
  $.subscribe('foo.bar', createLogger('foo.bar'));</p>

<p>  /<em>
   * logs:
   * foo 1 2
   * foo.bar 1 2
   * foo.baz 1 2
   </em>/
  $.publish('foo', [1, 2]);</p>

<p>  /<em>
   * logs:
   * foo.bar 3 4
   </em>/
  $.publish('foo.bar', [3, 4]);</p>

<p>Your Jigs Go Here
~~~~~~~~~~~~~~~~~
Please send me your favorite jigs. I would love to expand this post with more great Jigs.</p>

<p>Footnotes
~~~~~~~~~</p>

<p>.. [1] https://github.com/rwldrn/idiomatic.js/
.. [2] https://github.com/cowboy/jquery-tiny-pubsub</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functions Explained]]></title>
    <link href="http://heavysixer.github.com/blog/2013/02/15/functions-explained/"/>
    <updated>2013-02-15T12:10:00-06:00</updated>
    <id>http://heavysixer.github.com/blog/2013/02/15/functions-explained</id>
    <content type="html"><![CDATA[<p>A Deep Dive into JavaScript Functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>

<p>Based on my readership I have to assume most of you are familiar with JavaScript already. Therefore, it may seem odd to include a post on functions. After all, they are
one of the most rudimentary components of JavaScript. My assertion is this, just as a person can speak a language without the ability to read
or write it, so too can developers use functions in JavaScript and yet be blissfully unaware of their complexities.</p>

<p>Typically developers only become aware of the specifics of functions when something they wrote explodes in their face. My goal in this section
is to expose the intricacies of JavaScript functions to you, which will hopefully save you from having to pull syntactic shrapnel from your
codebase.</p>

<p>A word of caution before we begin; JavaScript is only as good as its interpreter. While the concepts we'll consider are well-covered in
the language spec, it does not mean that all runtime environments will work the same way. In other words your milage may vary. This section will
discuss common misconceptions of JavaScript functions, and the silent bugs they introduce. However, debugging functions in detail is not
covered. Fortunately, debugging has been documented by others in the JavaScript community especially in Juriy Zaytsev's excellent article "Named
Function Expressions Demystified" [1]_.</p>

<p>Blocks in JavaScript
~~~~~~~~~~~~~~~~~~~~</p>

<p>Before we can understand functions in JavaScript we have to understand blocks. JavaScript blocks are nothing more than statements grouped
together. Blocks start with a left curly bracket "{" and end with a right one "}". Simply put, <strong>blocks allow statements inside the brackets
to be executed together</strong>. Blocks form the most basic control structure in JavaScript. The following are a few examples of how blocks in
JavaScript:</p>

<p>.. code-block:: javascript</p>

<p>  // Block as an anonymous self-executing function
  ;!function () {</p>

<pre><code>  var triumph = false,
      cake = false,
      satisfaction = 0,
      isLie,
      note;

  // Block used as part of function expression
  var isLie = function (val) {
      return val === false;
  }

  // Block used as part of a conditional statement
  if (isLie(cake)) {
      triumph = true;
      makeNote('huge success');
      satisfaction += 10;
  }

  // Block used as part of a function declaration
  function makeNote(message) {
      note = message;
  }
</code></pre>

<p>  }();</p>

<p>As we saw above, functions are essentially <em>named blocks</em>, which the developer can invoke on demand. This is easy to demonstrate:</p>

<p>.. code-block:: javascript</p>

<p>  // The inline conditional block statement is executed only once per cycle.
  if (isLie(cake)) {</p>

<pre><code>  ...
</code></pre>

<p>  }</p>

<p>  function makeNote(message) {</p>

<pre><code>  ...
</code></pre>

<p>  }</p>

<p>  // The function declaration is executed as many times as it is called.
  makeNote("Moderate Success");
  makeNote("Huge Success");</p>

<p>Function Arguments
~~~~~~~~~~~~~~~~~~</p>

<p>Functions like control flow statements (if, for, while etc.) can be initialized by passing arguments into the function body. In JavaScript
variables are either a <strong>complex type</strong> (e.g. Object, Array) or a <strong>primitive type</strong> (e.g. String, Integer). When a complex object is supplied
as an argument it is <strong>passed by reference</strong> to the function body. Instead of sending a copy of the variable, JavaScript sends a pointer to its
location in memory. Conversely, when passing a primitive type to a function JavaScript <strong>passes by value</strong>. This difference can lead to subtle bugs
because conceptually we often treat functions as a black box, and assume they can only effect the enclosing scope by returning a variable.
With pass by reference, the argument object is modified even though it may not returned by the function. Pass by reference and pass by value
are demonstrated below:</p>

<p>.. code-block:: javascript</p>

<p>  var object = {</p>

<pre><code>  'foo': 'bar'
</code></pre>

<p>  },
  num = 1;</p>

<p>  // Passed by reference
  ;!function(obj) {</p>

<pre><code>  obj.foo = 'baz';
</code></pre>

<p>  }(object);</p>

<p>  // => 'baz'
  console.log(object);</p>

<p>  // Passed by value;
  ;!function(num) {</p>

<pre><code>  num = 2;
</code></pre>

<p>  }(num);</p>

<p>  // => 1
  console.log(num);</p>

<p>Function Types
~~~~~~~~~~~~~~~</p>

<p>Now that we have a better understanding of blocks, and arguments lets dive deeper into <strong>Function Declaration</strong> and <strong>Function Expression</strong>,
the two types of functions used in JavaScript. To the casual reader the two appear very similar:</p>

<p>.. code-block:: javascript</p>

<p>  // Function Declaration
  function isLie(cake){</p>

<pre><code>  return cake === true;
</code></pre>

<p>  }</p>

<p>  // Function Expression
  var isLie = function(cake){</p>

<pre><code>  return cake === true;
</code></pre>

<p>  }</p>

<p>The only real difference between the two, is when they are evaluated. A function declaration can be accessed by the interpreter as it is being
parsed. The function expression on the other hand is part of an assignment expression, which prevents JavaScript from evaluating it until the
program has completed the assignment. This difference may seem minor, but implications are huge; consider the following example:</p>

<p>.. code-block:: javascript</p>

<p>  // => Hi, I'm a function declaration!
  declaration();</p>

<p>  function declaration() {</p>

<pre><code>  console.log("Hi, I'm a function declaration!");
</code></pre>

<p>  }</p>

<p>  // => Uncaught TypeError: undefined is not a function
  expression();</p>

<p>  var expression = function () {</p>

<pre><code>  console.log("Hi, I'm a function expression!");
</code></pre>

<p>  }</p>

<p>As you can see in the previous example the <em>expression</em> function threw an exception when it was invoked, but the <em>declaration</em> function
executed just fine. This exception gets to the heart of the difference between declaration and expression functions. JavaScript <em>knows</em>
about declaration function and can parse it before the program executes. Therefore, it doesn't matter if the program invokes the function
before it is defined. This is because behind the scenes JavaScript has <em>hoisted</em> the function to the top of the current scope. The function
expression is not evaluated until it is assigned to a variable; therefore it is still <em>undefined</em> when invoked. This is why good code style is
to define all variables at the top of the current scope. Had we done this then our script would visually match what JavaScript is doing during
parsetime.</p>

<p>The concept to take away is that <strong>during parsetime JavaScript moves all function declarations to the top of the current scope</strong>. This is why
it doesn't matter where declarative functions appear in the script body.</p>

<p>To further explore the distinctions between declarations and expressions, consider the following:</p>

<p>.. code-block:: javascript</p>

<p>  function sayHi() {</p>

<pre><code>  console.log("hi");
</code></pre>

<p>  }</p>

<p>  var hi = function sayHi() {</p>

<pre><code>  console.log("hello");
</code></pre>

<p>  }</p>

<p>  // => "hello"
  hi();</p>

<p>  // => 'hi'
  sayHi();</p>

<p>Casually reading this code, one might assume that the declaration function would get clobbered because it function expression has an identical
name. However, since the second function is part of an assignment expression it is given its own scope, and JavaScript treats them as seperate
entities. To make things even more confusing look at this example:</p>

<p>.. code-block:: javascript</p>

<p>  var sayHo</p>

<p>  // => function
  console.log(typeof (sayHey))</p>

<p>  // => undefined
  console.log(typeof (sayHo))</p>

<p>  if (true) {</p>

<pre><code>  function sayHey() {
      console.log("hey");
  }

  sayHo = function sayHo() {
      console.log("ho");
  }
</code></pre>

<p>  } else {</p>

<pre><code>  function sayHey() {
      console.log("no");
  }

  sayHo = function sayHo() {
      console.log("no");
  }
</code></pre>

<p>  }</p>

<p>  // => no
  sayHey();</p>

<p>  // => ho
  sayHo();</p>

<p>In the previous example we saw that functions of the same name were considered different if one was an expression and the other was a
declaration. In this example we are attempting to conditionally define the function based on how the program executes. Reading the script's
control flow you'd expect <em>sayHey</em> to return "hey" since the conditional statement evaluates true. Instead it returns "no", meaning the second
version of the <em>sayHey</em> function clobbered the first. Even more confusing is that the <em>sayHo</em> function behaves the opposite way! Again, the
difference comes down to parsetime versus runtime.</p>

<p>We already learned that when JavaScript parses the script it collects all of the function declarations and hoists them to the top of the current
scope. When this happens it clobbers the first version of <em>sayHey</em> with the second because they exist in the same scope. This explains why
it returns "no." We also know that function expressions are ignored by the parser until the assignment process completes. Assignment happens
during runtime, which is also when the conditional statement is evaluated. That explains why the <em>sayHo</em> function was able to be conditionally
defined. The key to remember here is that <strong>function declarations can not be conditionally defined. If you need conditional definition use a function expression</strong>.
Furthermore, <strong>function declarations should NEVER be made inside a control flow statement</strong>, due to the different ways interpreters handle it.</p>

<p>Function Scopes
~~~~~~~~~~~~~~~</p>

<p>Unlike many other languages which are scoped to the block, JavaScript is scoped to the function. In Ruby (version 1.9.+) you can write this:</p>

<p>.. code-block:: javascript</p>

<p>  x = 20
  10.times do |x|</p>

<pre><code># =&gt; 0..9
puts x
</code></pre>

<p>  end</p>

<p>  # => 20
  puts x</p>

<p>What this demonstrates is that each block gets its own scope. Conversely, if we wrote similar code in JavaScript:</p>

<p>.. code-block:: javascript</p>

<p>  var x = 20;</p>

<p>  // Functions have their own scope
  ;!function() {</p>

<pre><code>  var x = "foo";

  // =&gt; "foo"
  console.log(x);
</code></pre>

<p>  }();</p>

<p>  // => 20
  console.log(x);</p>

<p>  for (x = 0; x &lt; 10; x++) {</p>

<pre><code>  // =&gt; 0..9
  console.log(x);
</code></pre>

<p>  }</p>

<p>  // => 10
  console.log(x);</p>

<p>In JavaScript <em>x</em> is available inside the for loop, because as a control statement it belongs to the enclosing scope. This is not intuitive to
many developers used to block level scope. JavaScript handles the need of block level scope at least partially through the use of closures
which we'll discuss later.</p>

<p>Debugging Functions
~~~~~~~~~~~~~~~~~~~</p>

<p>Before we wrap this topic up, lets briefly touch on debugging functions. In JavaScript naming a function expression is completely optional;
so why do it? The answer is to aid the debugging process. Named function expressions have access to their name within the newly defined scope,
but not in the enclosing scope. Without a name their anonymous nature can make them feel a bit like ghosts in the machine when it comes to
debugging.</p>

<p>.. code-block:: javascript</p>

<p>  var namedFunction = function named() {</p>

<pre><code>  // =&gt; function
  console.log(typeof(named));
</code></pre>

<p>  }
  namedFunction();</p>

<p>  // => undefined
  console.log(typeof(named));</p>

<p>Nameless function expressions will be displayed in the stack trace as "(anonymous function)" or something similar. Naming your function
expression gives you clarity when trying to unwind an exception whose call stack may feel miles long.</p>

<p>.. code-block:: javascript</p>

<p>  /<em>
   * It is much harder to debug anonymous function expressions
   * Uncaught boom
   *    - (anonymous function)
   *    - window.onload
   </em>/
  ;!function(){</p>

<pre><code>  throw("boom");
</code></pre>

<p>  }();</p>

<p>  /<em>
   * Naming your function expressions give you a place to start looking when debuggin.
   * Uncaught boom
   *    - goBoom
   *    - window.onload
   </em>/
  ;!function goBoom() {</p>

<pre><code>  throw("boom")
</code></pre>

<p>  }();</p>

<p>.. [1] http://kangax.github.com/nfe/</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pragmatic JavaScript Style]]></title>
    <link href="http://heavysixer.github.com/blog/2013/02/15/pragmatic-javascript-style/"/>
    <updated>2013-02-15T09:08:00-06:00</updated>
    <id>http://heavysixer.github.com/blog/2013/02/15/pragmatic-javascript-style</id>
    <content type="html"><![CDATA[<h1>The Elements Of Style</h1>

<p>My goal is to make you a better programmer, and I am going to do this by teaching you about style. I am not talking about fashion, because I
think most programmers would flunk that test; unless, comic-con couture is a thing. Instead we'll talk about the importance of style, how it
forms, how it spreads and when to kill it. Specifically, we'll look at style as it applies to programming. Ultimately, once we have a context
for evaluating style I will introduce you to elements of programmatic style which have served me well over the years as a professional
software developer.</p>

<h2>What Is Style?</h2>

<p>Style is often used as a measurement of quality. When someone is described as having style or being stylish, it is almost universally meant as
a complement. If someones' style ever comes into question it is usually in comparison to someone else's style. "My style's the best and so I
challenge you" screams 70's era martial arts star.</p>

<p>Stylishness is a fresh approach, a unique perspective, an unexpected insight into an activity. The application of a style can become so
prominent that it expands the activity itself; that house is built in a Frank Lloyd Wright style. What starts as a personal style in painting
can become an art movement almost overnight. Style spreads like a virus, it is the original meme, a mind virus that changes the way you see
the world forever. Style is often the conduit where new ideas pulsate.</p>

<p>How does style effect programmers? Well the good news about style for those algorithmically inclined is that, no matter how personal a style
may seem, for it to exist it all, it must at some level be repeatable. Style must be codified into a series of steps, rules or combinations
that can be followed, and then recognized by others. Therefore if style is a measurement of quality, and at the same time repeatable then it
can be taught. Just ask Strunk and White.</p>

<p>William Strunk Jr. wrote "The Elements of Style" while he was a professor at Cornell. He began with 7 rules for the usage of language, and 11
principles of composition. His student E.B. White revised the book forty years later, by adding an additional 4 rules. The goal of the book
was to give aspiring writers and grammarians a context from which to evaluate their own work.</p>

<p>According to White, Strunk was compelled to write the "little book" out of sympathy for those afflicted with reading the writer's ill-composed
dreck: "Will felt that the reader was in serious trouble most of the time, floundering in a swamp and that it was the duty of anyone
attempting to write English to drain the swap quickly and get the reader up on dry ground, or at least throw a rope."</p>

<p>Over the years the book has remained wildly popular by those learning to write efficiently, and is affectionately referred to as "Strunk and
White." That is not to say it has been universally loved or followed. Dorothy Parker is quoted in the New York Times as saying "If you have
any young friends who aspire to become writers, the second-greatest favor you can do them is to present them with copies of 'The Elements of
Style.' The first-greatest, of course, is to shoot them now, while they're happy."</p>

<p>Many found the rules too restrictive, and opinionated. White said Strunk believed "...it was worse to be irresolute than to be wrong."
Strunk's assertions is that it takes passion to be stylish. You need to be able to draw boundaries, to allow this idea to flourish while
forcing that one to die. Style is a sine wave attracting some and repelling others.</p>

<h2>What is programmatic style?</h2>

<p>As mentioned previously, Stunk and White wrote their book not only to empower and train writers, but to save readers from slogging through
what was in their minds a textual tar pit. So too, good programmatic style services two audiences, the developer and the processor. That is
to say that the code should be well-written, both syntactically, and technically. Below are qualities I consider essential in application
of programmatic style:</p>

<p><strong>Consistency</strong> - By repeatedly applying rules to the codebase we ensure consistency. Consistency, mitigates noise in the codebase, and
brings the intent of the code into clearer focus. Put another way, if a developer is trying to piece together how to read your code, you have
prevented them from understanding what it does. Consistency is concerned with how the code looks, e.g. naming conventions, use of whitespace,
and method signatures; and how the code is written for example ensuring that all functions don't return a string in one context and an integer
in another.</p>

<p><strong>Expressiveness</strong> - Code is by nature a symbolic language, where variability and abstractness is implicit. Therefore the developer must find a
way to make the code meaningful to the reader. This can be archived though naming variables and methods precisely. When reviewing a class,
method or variable the reader should understand the roles and responsibilities of the code by reading the code itself. If a method can only
be understood by reading the comments above left by the writer it should be a clue that the code is not expressive.</p>

<p><strong>Succinctness</strong> - Strive to do just enough. Good programming like good writing is  about clarity of purpose, and not merely
compactness. It should be about reducing the complexity of a method, not it's usefulness.</p>

<p><strong>Restraint</strong> - Style should never overpower the subject itself. At that point style becomes the
subject it becomes a facile artifice, a dish ruined by too much spice. I am reminded of a minimalist chess set I saw in college every piece
was either a white or black cube, and all pieces were the same size. It was aesthetically beautiful and simultaneously unplayable.</p>

<h2>JavaScript Style Guide</h2>

<p>This style guide was compiled by compiling, reviewing and considering choices I have made in my own work over the years, and coding practices
of individuals, and development teams I admire in the JavaScript community. As such this style guide should be seen as an amalgamation of
inputs and influences from the larger JavaScript community rather than the creative output of a singular individual. You can find a list of
resources used in this guide in the additional resources section. This guide is broken into two sections: "Rules for Visual Clarity" and
"Rules for Computational Effectiveness".</p>

<h2>Caveats</h2>

<p>Style guides are just that guides, they are meant to point you in the right direction, but they are at best mutable truth. Moreover,  coding
theory changes constantly and it is important not to lock yourself into a dogmatic approach to the application of these styles. As my
professor Clyde Fowler told me in my studio drawing class, "you must think with your hands", and what he meant by that was you must think
through doing, while maintaining the ability to get critical distance from your work.</p>

<h2>Rules for Clarity - How others see code</h2>

<p>Rules Of Thumb
~~~~~~~~~~~~~~</p>

<ul>
<li><strong>Write Clearly And Expressively</strong> - When naming variables, functions, or organizing code remember you are writing for humans to read it
not compilers.</li>
<li><strong>Following Existing Conventions</strong> - If you share your code anywhere, work on a team, or are hired to write code, then you are not writing
for yourself</li>
<li><strong>Write in Only One Language</strong> - Where possible don't use JavaScript as a surrogate for other languages.
This means resisting the urge to write inline HTML, or CSS where possible.</li>
<li><strong>Enforce A Uniform Column Width</strong> - Strive for consistent line lengths in source code. Long lines tire the eyes, and cause needless
horizontal scrolling. An industry standard is 80 characters per line.</li>
</ul>


<p>Document Formatting
~~~~~~~~~~~~~~~~~~~</p>

<ol>
<li>Naming Conventions</li>
</ol>


<p>JavaScript is a terse language of brackets, and symbols and one of the only way to make your code expressive to humans is through the names
you choose for variables, functions and classes among others. Remember when choosing a name it should describe the role and responsibilities
of that object. Vague or obtuse names like <em>doStuff</em> is like telling the reader <em>you figure it out</em>, which often times they won't.</p>

<ul>
<li>Choose variables and functions with meaningful, expressive and descriptive names. Write for the reader not the compiler.</li>
</ul>


<p>.. code-block:: javascript</p>

<p>  // Bad
  var a = 1,</p>

<pre><code>  aa = function(aaa) {
      return '' + aaa;
  };
</code></pre>

<p>  // Good
  var count = 1,</p>

<pre><code>  toString = function(num) {
      return '' + num;
  };
</code></pre>

<ul>
<li>Constants should always belong to a namespace, and be written in uppercase with spaces replaced with underscores</li>
</ul>


<p>.. code-block:: javascript</p>

<p>  // Bad
  MY_CONSTANT = 43;</p>

<p>  // Good
  com.humansized.MY_CONSTANT = 43;</p>

<ul>
<li>Variables should be CamelCase</li>
</ul>


<p>.. code-block:: javascript</p>

<p>  myVariableName</p>

<ul>
<li>Classes should be PascalCase</li>
</ul>


<p>.. code-block:: javascript</p>

<p>  MyAwesomeClass</p>

<ul>
<li>Functions should be CamelCase</li>
</ul>


<p>.. code-block:: javascript</p>

<p>  isLie(cake)</p>

<ul>
<li>Namespaces should be CamelCase and use periods as a delimiter</li>
</ul>


<p>.. code-block:: javascript</p>

<p>  com.site.namespace</p>

<ul>
<li>Hungarian notation is not required but you can use it to convey they are objects constructed through or dependent on a library or framework</li>
</ul>


<p>.. code-block:: javascript</p>

<p>  // JQuery infused variable
  var $listItem = $("li:first");</p>

<p>  // Angular.js uses the dollar sign to refer to angular-dependent variables
  $scope, $watch, $filter</p>

<ol>
<li><p>Constants And Variables</p></li>
<li><p>Variables and constants definitions always go at the top of the scope</p></li>
</ol>


<p>.. code-block:: javascript</p>

<p>  // Bad
  function iterate() {</p>

<pre><code>  var limit = 10;
  for (var x = 0; x &lt; limit; x++) {
      console.log(x);
  }
</code></pre>

<p>  }</p>

<p>  // Good
  function iterate() {</p>

<pre><code>  var limit = 10,
      x = 0;

  for (x = 0; x &lt; limit; x++) {
      console.log(x);
  }
</code></pre>

<p>  }</p>

<ul>
<li>Avoid polluting the global namespace by always declaring variables using <em>var</em></li>
</ul>


<p>.. code-block:: javascript</p>

<p>  // Bad
  foo = 'bar';</p>

<p>  // Good
  var foo = 'bar';</p>

<ul>
<li>Declare multiple variables using a single var declaration, but separate each variable with a newline</li>
</ul>


<p>.. code-block:: javascript</p>

<p>  // Bad
  var foo = "foo";
  var note = makeNote('Huge Success');</p>

<p>  // Good
  var foo = "foo",</p>

<pre><code>  note = makeNote('Huge Success');
</code></pre>

<ul>
<li>Declare unassigned variables last. This allows the reader to know they are needed but have delayed initialization.</li>
<li>Do not assign variables inside a conditional statement, it often masks errors.</li>
</ul>


<p>.. code-block:: javascript</p>

<p>  // Bad because it is easily misread as an equality test.
  if (foo = bar) {...}</p>

<ul>
<li>Do not clobber arguments with variables names.</li>
</ul>


<p>.. code-block:: javascript</p>

<p>  // Bad
  function addByOne(num) {</p>

<pre><code>  var num = num + 1;
  return num;
</code></pre>

<p>  }</p>

<p>  // Good
  function addByOne(num) {</p>

<pre><code>  var newNum = num + 1;
  return newNum;
</code></pre>

<p>  }</p>

<ol>
<li><p>Page Layout</p></li>
<li><p>Blank lines</p>

<ul>
<li>Should always proceed the start of a comment</li>
<li><p>Should be used to separate logically related code</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  var = wheels;</p>

<p>  wheels.clean()</p>

<p>   car.apply(wheels);</p>

<p>  truck.drive();</p>

<p>  // Good
  var = wheels;
  wheels.clean()
   car.apply(wheels);</p>

<p>  truck.drive();</p></li>
</ul>
</li>
<li><p>Commas</p>

<ul>
<li><p>Remove trailing comments in object declarations. It will break some runtime environments.</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  var foo = {</p>

<pre><code>  bar: 'baz',
  foo: 'bar',
</code></pre>

<p>  }</p>

<p>  // Good
  var foo = {</p>

<pre><code>  bar: 'baz',
  foo: 'bar'
</code></pre>

<p>  }</p></li>
<li><p>Don't use comma first formatting, if you don't know what that means keep it that way!</p></li>
</ul>
</li>
<li><p>Semicolons</p>

<ul>
<li>Even though JavaScript determines semicolons to be optional many compilers expect them, therefore it is better to use them.</li>
<li>Useful for clearly delineating the end of a logical statement</li>
<li>Do not add meaningless semicolons</li>
</ul>
</li>
<li><p>Whitespace</p>

<ul>
<li>Should be removed from the end of a line</li>
<li>Should be removed from a blank line</li>
<li>Should not mix spaces and tabs</li>
<li><p>Should appear after each comma in a function declaration</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  function findUser(foo,bar,baz)</p>

<p>  // Good
  function findUser(foo, bar, baz)</p></li>
<li><p>Should not appear inside empty functions or literals</p>

<p>.. code-block:: javascript</p>

<p>  doThis();
  var foo = {};
  var arr = [];</p></li>
</ul>
</li>
<li><p>Brackets And Braces</p>

<ul>
<li>Use only where the compiler calls for it or where it enhances readability</li>
<li><p>Brackets should appear on the line that requires them</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  if (hidden)
  {
   ...
  }</p>

<p>  // Good
  if (hidden) {</p>

<p>  }</p></li>
<li><p>Add whitespace in front and between brackets to aid readability.</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  if (condition) goTo(10);</p>

<p>  // Good
  if (condition) {</p>

<pre><code>  goTo(10);
</code></pre>

<p>  }</p></li>
<li><p>There are a couple of exception to the previous rule</p>

<p>.. code-block:: javascript</p>

<p>  // No Whitespace needed when there is a single argument
  if (foo) ...</p>

<p>  // No whitespace when a parenthesis is used as a scope container
  ;(function () {...})</p>

<p>  // No white space when brackets are used as a function argument
  function sortThis([2,3,4,1])</p></li>
</ul>
</li>
<li><p>Strings</p>

<ul>
<li><p>String should be constructed using single quotes</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  var foo = "Bar";</p>

<p>  // Good
  var foo = 'Bar';</p></li>
<li><p>Strings longer than the pre-determined character line limit should be reconsidered, if required they should be concatenated</p></li>
</ul>
</li>
<li><p>Functions</p>

<ul>
<li>Method signatures must be consistent. If a function returns a variable in one context it should return a variable in all contexts</li>
</ul>


<p>.. code-block:: javascript</p>

<p>  // Bad
  var findFoo(isFoo) {</p>

<pre><code>  if ( isFoo === true ) {
      return true;
  }
</code></pre>

<p>  }</p>

<p>  // Good
  var findFoo(isFoo) {</p>

<pre><code>  if ( isFoo === true ) {
      return true;
  }
  return false;
</code></pre>

<p>  }</p>

<ul>
<li><p>While not a requirement, returning early from a function can make the intent more clear</p>

<p>.. code-block:: javascript</p>

<p>  // Good
  var findFoo(isFoo) {</p>

<pre><code>  if ( isFoo === true ) {
      return true;
  }
  return false;
</code></pre>

<p>  }</p></li>
</ul>
</li>
<li><p>Comments</p>

<ul>
<li>Should never trail a statement</li>
<li>Comments should be used sparingly, overuse of comments should suggest to the developer that their code is not expressive enough.</li>
<li>Comments should aways be written as a complete thought.</li>
<li><p>Multiline comments should always use the multiline syntax</p>

<p>.. code-block:: javascript</p>

<p>  // Some really
  // bad multiline comment</p>

<p>  /**</p>

<ul>
<li> A well-formed multiline comment</li>
<li> so there...
*/</li>
</ul>
</li>
</ul>
</li>
</ol>


<h2>Rules for Computational Effectiveness</h2>

<p>Rules Of Thumb
~~~~~~~~~~~~~~
* <strong>Assume File Will Be Concatenated</strong> - Modern applications often munge source JavaScript into a streamline file for production. You should
  defensively program your scripts to protect from switches in operation context and scope corruption.</p>

<ul>
<li><strong>Keep your code browser agnostic</strong> - Keep your business logic free of browser specific code by abstracting them into interfaces. This will
keep your code on a clean upgrade path as browser fall in and out of fashion.</li>
<li><strong>Never Use eval()</strong> - Ever</li>
<li><strong>Never Use with()</strong> - Ever</li>
<li><p><strong>Keep Prototype Pristine</strong> - Never modify the prototype of a builtins like Array.prototype because it can silently break other's code which
expect standard behavior.</p></li>
<li><p>Equality Comparisons And Conditional Evaluation</p></li>
<li><p>Use "===" instead of "==" use "!==" instead of "!=" this is because JavaScript is very loose when testing equality.</p></li>
<li><p>When just testing for truthiness you can coerce the values</p>

<p>.. code-block:: javascript</p>

<p>  if (foo) {...}
  if (!foo) {...}</p></li>
<li><p>When testing for emptiness</p>

<p>.. code-block:: javascript</p>

<p>  if (!arr.length) { ... }</p></li>
<li><p>You must be explicit when testing for truth</p>

<p>.. code-block:: javascript</p>

<p>  // Bad because all of these will be coerced into true
  var zero = 0,
  empty = "",
  knull = null,
  notANumber = NaN,
  notDefined</p>

<p>  if (!zero || !empty || !knull || !notANumber || !notDefined ) ...</p>

<p>  // Bad
  var truth = "foo",
  alsoTrue = 1</p>

<p>  if (truth &amp;&amp; alsoTrue) ...</p>

<p>  // Good
  if (foo === true) ...</p></li>
<li><p>Constants and Variables</p></li>
<li><p>When deleting a variable set it to null instead calling #delete or setting it to undefined</p>

<p>.. code-block:: javascript</p>

<p>  // Bad because undefined means the variable is useful but as yet has no value
  this.unwanted = undefined;</p>

<p>  /**</p>

<ul>
<li> Bad because calling delete is much slower than reassigning a value.</li>
<li> The only reason to use delete is if you want to remove the attribute from an objects list of keys.
*/
delete this.unwanted;</li>
</ul>


<p>  // Good
  this.unwanted = null;</p></li>
<li><p>Functions</p></li>
<li><p>Function Expressions</p>

<p>.. code-block:: javascript</p>

<p>  // Anonymous Function
  var anon = function () {</p>

<pre><code>  return true;
</code></pre>

<p>  }</p>

<p>  // Named Function
  var named = function named() {</p>

<pre><code>  return true;
</code></pre>

<p>  };</p>

<p>  // Immediately-invoked function, hides its contents from the executing scope.
  ;(function main() {</p>

<pre><code>  return true;
</code></pre>

<p>  })();</p></li>
<li><p>Anonymous functions are defined at parse-time, and therefore do not have their names hoisted to the top of the scope.</p>

<p>.. code-block:: javascript</p>

<p>  // Bad - Runtime Error
  iGoBoom();</p>

<p>  var iGoBoom = function () {</p>

<pre><code>  alert('boom');
</code></pre>

<p>  }</p>

<p>  // Good
  iGoBoom();
  function iGoBoom() {</p>

<pre><code>  alert('boom');
</code></pre>

<p>  }</p></li>
<li><p>Do not use function declaration within block statements it is not part of  ECMAScript; instead use a function expression.</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  if (ball.is(round)) {</p>

<pre><code>  function bounce(){

      // Statements Continue
  }
  return bounce()
</code></pre>

<p>  }</p>

<p>  // Good
  if (ball.is(round)) {</p>

<pre><code>var bounce = function () {

    // Statements Continue
}
</code></pre>

<p>  }</p></li>
<li><p>Do not hide the native arguments object by using the same name in a function</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  var foo = function(arguments) {</p>

<pre><code>  alert(arguments.join(' '));
</code></pre>

<p>  }</p>

<p>  // Good
  var foo = function(args) {</p>

<pre><code>  alert(args.join(' '));
</code></pre>

<p>  }</p></li>
<li><p>Strings</p></li>
<li><p>When concatenating a string use Array#join for performance reasons.</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  var lorem = 'Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\
  Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in\
  reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in\
  culpa qui officia deserunt mollit anim id est laborum.';</p>

<p>  // Good
  var lorem = ['Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.',
  'Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in',
  'reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in',
  'culpa qui officia deserunt mollit anim id est laborum.'].join('');</p></li>
<li><p>Objects</p></li>
<li><p>Should use object literal vs new Object</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  var person = new Object();
  person.firstName = "John";
  person.lastName = "Doe";</p>

<p>  // Good
  var person = {</p>

<pre><code>firstName: "John",
lastName: "Doe"
</code></pre>

<p>  }</p></li>
<li><p>Don't overwrite reserved words as keys</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  var person = { class : "Person" };</p>

<p>  // Good
  var person = { klass : "Person" };</p></li>
<li><p>Arrays</p></li>
<li><p>Should use literal syntax for creation</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  var arr = new Array();</p>

<p>  // Good
  var arr = [];</p></li>
<li><p>Responsibility Delegation</p></li>
<li><p>Only write code that is the responsibility of the program. Keep your code free of view layer and template code. Use a template library
like mustache.js instead</p>

<p>.. code-block:: javascript</p>

<p>  var view = {</p>

<pre><code>  title: "Joe",
  calc: function () {
      return 2 + 4;
  }
</code></pre>

<p>  }, output;</p>

<p>  // Bad
  output = '<div><h5>' + title + '</h5><p>' + calc() + '</div>';</p>

<p>  // Good
  var output = Mustache.compilePartial('my-template', view);</p></li>
<li><p>Keep JavaScript out of the HTML</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  <button onclick="doSomething()" id="something-btn">Click Here</button></p>

<p>  // Good
  var element = document.getElementById("something-btn");
  element.addEventListener("click", doSomething, false);</p></li>
<li><p>Operating Context And Scope</p></li>
<li><p>Where possible wrap your code inside self executing functions. This will insulate your code from pollution by others, and make it easier
to abstract</p>

<p>.. code-block:: javascript</p>

<p>  // Good
  ;(function( window, document, undefined) {</p>

<pre><code>// My Awesome Library
</code></pre>

<p>  })(this, document);</p></li>
<li><p>Design for duration-agnostic execution of code. This will prevent your code from building up a backlog of requests that may no longer
be relevant</p>

<p>.. code-block:: javascript</p>

<p>  // Bad because this might take longer than 100 milliseconds to complete.
  setInterval(function () {</p>

<pre><code>findFoo();
</code></pre>

<p>  }, 100);</p>

<p>  // Good this will only be called again once findFoo has completed.
  ;(function main() {</p>

<pre><code>  findFoo();
  setTimeout(main, 100);
</code></pre>

<p>  })();</p></li>
<li><p>Only use <em>this</em> in object constructors, methods and creating closures</p></li>
<li><p>To prevent breaking community code declaring an operating context e.g. <code>"use strict"</code> should be wrapped inside a self-executing function
for modules or inside a function itself when needed</p>

<p>.. code-block:: javascript</p>

<p>  // Bad
  var bar = findLooseyGoosey();</p>

<p>  "use strict";</p>

<p>  var foo = findStrictly();</p>

<p>  // Good
  var bar = findLooseyGoosey();</p>

<p>  ;(function () {</p>

<pre><code>"use strict";
var foo = findStrictly();
</code></pre>

<p>  })();</p></li>
<li><p>Coercion</p></li>
<li><p>Conversion over Coercion</p>

<p>.. code-block:: javascript</p>

<p>  var num = '1';</p>

<p>  // Bad implicit coercion
  num = +num;</p>

<p>  // Good expressive conversion
  num = Number(num);</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spineless 0.2.1 Released]]></title>
    <link href="http://heavysixer.github.com/blog/2012/06/24/spineless-0-dot-2-1-released/"/>
    <updated>2012-06-24T14:43:00-05:00</updated>
    <id>http://heavysixer.github.com/blog/2012/06/24/spineless-0-dot-2-1-released</id>
    <content type="html"><![CDATA[<p>I have just pushed a new release of my JavaScript application framework called Spineless. Spineless is a simple MVC stack without the need of a backbone.
<a href="https://github.com/heavysixer/spineless">https://github.com/heavysixer/spineless</a></p>

<p>The goal of Spineless is to provide "just enough framework" to succeed. If I have done my job, you should be able to write your first Spineless app in less than 10 minutes.</p>

<p>Spineless is meant to run with virtually no dependencies. In the age of frameworks with massive dependency chains, here is a list of things you <em>DO NOT</em> need to run spineless.</p>

<ol>
<li>A persistance layer (e.g. database)</li>
<li>A backend server (e.g. node.js)</li>
<li>An internet connection! (srsly)</li>
</ol>


<p>Spineless has only two dependencies, JQuery and Mustache.js, both which come bundled
with the project inside the /lib directory.</p>

<p>Like any good MVC framework Spineless uses the concept of models, controllers and views.</p>

<ol>
<li>Spineless models are essentially JavaScript objects and completely optional.</li>
<li>Controllers are used to marshall commands from the views to the models where needed.</li>
<li>Views are the visual interface that the user sees.</li>
</ol>


<p>In addition to the normal MVC stack, Spineless also uses the concept of helpers and templates.</p>

<ol>
<li>Templates are HTML snippets, which are used by views to get better use of reusable code.</li>
<li>Helpers are functions that modify a template's variables any way you choose.</li>
</ol>


<h2>Going Spineless in 10 minutes or less</h2>

<p>The entire Spineless application resides inside the ".application" div. An application consists
of a collection of controllers which in turn contain a collection of views.
Consider the following example:</p>

<p>```html</p>

<pre><code>&lt;div class="application"&gt;
  &lt;div class="controller" data-controller='application'&gt;
    &lt;div class="view" data-action='index'&gt;
      Hello World!
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>```</p>

<p>In this example you'll see that we have defined an application with a single controller. The name of the controller is defined by the <code>data-controller</code> attribute. This attribute is required by Spineless to route requests to the proper location. Views are much like controllers, but instead of using the <code>data-controller</code> attribute they use the <code>data-action</code>.</p>

<h2>Routing Requests</h2>

<p>Routing requests through Spineless is incredibly painless to make any link a spineless request just add the "route" class. For example:</p>

<p>``` html</p>

<pre><code>&lt;a class="route" href="http://heavysixer.github.com/application/hello"&gt;Hello&lt;/a&gt;
</code></pre>

<p>```</p>

<p>When the user clicks on this link they will now be routed to the application controller where the <code>#hello</code> method will be called. If you are not using an element that support the <code>href</code> attribute you can also place your url inside a <code>data-href</code> attribute:</p>

<p>``` html</p>

<div class="route" data-href="/application/hello">Hello</div>


<p>```</p>

<p>If you want to manually trigger a route request from within JavaScript you can call the <code>get</code> function:</p>

<p>```javascript</p>

<pre><code>spineless.get('application', 'index');`
</code></pre>

<p>```</p>

<h2>Passing local variables to templates</h2>

<p>When rendering templates, Spineless substitutes predefined template variables with those you supply using JSON. The JSON can be provided in at least two ways:</p>

<ol>
<li>By url encoded a json object into the <code>data-locals</code> attribute.</li>
<li>Creating of modifying the JSON object using a helper function.</li>
</ol>


<p>I will explain the helper function method next, but here is a simple example of what the data-locals method looks like:</p>

<p>```html</p>

<pre><code>&lt;div data-locals="{&amp;quot;name&amp;quot;:&amp;quot;Mark&amp;quot;}" data-template='hi-my-name-is'&gt;&lt;/div&gt;
</code></pre>

<p>```</p>

<h2>Helper functions</h2>

<p>Helpers are developer-created functions that execute during the rendering of specific templates. Just like in Rails, helpers are available globally across all views. To demonstrate, imagine we have two DIV tags with locals supplied as urlencoded JSON object:</p>

<p>``` html</p>

<pre><code>&lt;div data-locals="{&amp;quot;name&amp;quot;:&amp;quot;Mark&amp;quot;}" data-template='hi-my-name-is'&gt;&lt;/div&gt;
&lt;div data-locals="{&amp;quot;name&amp;quot;:&amp;quot;Slim Shady&amp;quot;}" data-template='hi-my-name-is'&gt;&lt;/div&gt;
</code></pre>

<p>```</p>

<p>As you can see these objects have a property called <code>name</code>, each with unique values. These locals are linked to the hi-my-name-is template. To create a helper well bind a function to execute whenever the <code>hi-my-name-is</code> template is rendered. Doing this will allows us intercept the template instance's data-locals object and modify it anyway we choose before passing it along to Mustache to render. Here is the full example of the helper function:</p>

<p>``` javascript</p>

<pre><code>var sp = $.spineless({
    helpers: {
        'hi-my-name-is': function(obj) {
            if (obj.name === 'Slim Shady') {
                obj.name = "*wikka wikka* " + obj.name;
            }
            return (obj);
        }
    }
});
</code></pre>

<p>```</p>

<h2>PubSub for Spineless events</h2>

<p>Spineless now has a very minimal publisher subscriber (PubSub) events framework. The goal of this is to allow other code executing outside of Spineless to receive updates when internal Spineless events execute, without having to know anything about how Spineless is implemented. Here is a trivial example of creating an observer that is triggered every time a view is done rendering.</p>

<p>``` javascript</p>

<pre><code>$(document).ready(function() {
    var sp = $.spineless();
    sp.subscribe('afterRender',
    function(publisher, app) {
        app.request.view.append("&lt;h1&gt;Yes it has!&lt;/h1&gt;")
    })
    sp.get('application', 'index');
});
</code></pre>

<p>```</p>

<p>When the publisher executes a subscribers function it passes a reference to itself and the Spineless app instance as arguments. This allows the receiver to manage its subscriptions and gives the function access to the the Spineless current request, params hash among other things.</p>

<h2>Controller functions</h2>

<p>Controller functions are optional code that developers can write to augment the rendering of the view. Controller functions work much like helper functions do, in that they are executed before the view is returned to the screen. Unlike helper functions which are linked to an arbitrary number of templates; controller functions are scoped to just one controller action. Consider this example which executes when someone visits <code>/users/update</code>:</p>

<p>```javascript</p>

<pre><code>var sp = $.spineless({
    controllers: {
        users: {
            update: function(elements, request) {
                if ($.currentUser.isAdmin()) {
                    this.render(elements);
                } else {
                    alert(Access Denied);
                }
            }
        }
    }
});
sp.get('application', 'index');
</code></pre>

<p>```</p>

<p>I have added examples of all of these new features in the /samples folder of the public Github repo. Please feel free to open bug reports or feature requests, and I will do my best to oblige.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[client-side request caching with JavaScript]]></title>
    <link href="http://heavysixer.github.com/blog/2012/03/28/client-side-request-caching-with-javascript/"/>
    <updated>2012-03-28T20:30:00-05:00</updated>
    <id>http://heavysixer.github.com/blog/2012/03/28/client-side-request-caching-with-javascript</id>
    <content type="html"><![CDATA[<p>Recently I was writing an enterprise data visualization application that made heavy user of interactive charts and graphs. Like most best-of-breed data-viz apps this one supported very robust filters for slicing and dicing through the dataset. Each time the user adjusted one of these filters the application made new AJAX request and idled until the results were returned.</p>

<p>Technically, this approach worked fine, but because the data-segmentation occurred on the server the charts felt sluggish because they were always polling or data. Additionally, the user quite frequently toggled between only a couple filters to compare the results. What should have been an experience of rapidly flipping between two views on the data was actually a belabored rendering experience. As the developer this was frustrating because they were asking for and receiving the same data over and over again.</p>

<p>To solve this problem, I built a very simple mechanism that affords <em>just enough caching</em> to persist these payload objects only while the user is viewing the page. In this way the user would be guaranteed to get a fresh copy from the server on each page load.</p>

<p>Essentially, I hooked my caching routine around the function that made the AJAX request for new chart data. Using this approach an AJAX request only occurred once, and all future requests pulled from the cache.</p>

<p>``` javascript
// Called when someone adjusts a filter
function updateChart(url, chart, key) {</p>

<pre><code>// Builds the request params needed to correctly query the server. 
var opts = requestParamsFor(chart, key);

// Generate a cache key based on this object
var cacheKey = $.cache.getKey(opts);

if ($.hh.cache.exists(cacheKey)) {

    // If the key exists then the request has happened in the past
    // use the cached result to refresh the chart.
    var result = $.cache.get(cacheKey);
    onSuccess(kind, opts, chart, code, result);
} else {
    $.ajax({
        url: url,
        type: 'POST',
        data: opts,
        success: function(result) {

            // Since this was a new request store the results in the cache 
            // at the location specified by the cache key.
            $.cache.add(cacheKey, result);
            onSuccess(kind, opts, chart, code, result);
        }
    });
}
</code></pre>

<p>}</p>

<p>```</p>

<p>Here is the local cache class in all it's detail:</p>

<p>``` javascript
$.cache = (function() {</p>

<pre><code>var _cache = {};
var _keys = [];
var _indexOf = function(arr, obj) {
    var len = arr.length;
    for (var i = 0; i &lt; len; i++) {
        if (arr[i] == obj) {
            return i;
        }
    }
    return - 1;
};
var _serialize = function(opts) {
    if ((opts).toString() === "[object Object]") {
        return $.param(opts);
    } else {
        return (opts).toString();
    }
};
var _remove = function(key) {
    var t;
    if ((t = _indexOf(_keys, key)) &gt; -1) {
        _keys.splice(t, 1);
        delete _cache[key];
    }
};
var _removeAll = function() {
    _cache = {};
    _keys = [];
};
var add = function(key, obj) {
    if (_keys.indexOf(key) === -1) {
        _keys.push(key);
    }
    _cache[key] = obj;
    return $.hh.cache.get(key);
};
var exists = function(key) {
    return _cache.hasOwnProperty(key);
};
var purge = function() {
    if (arguments.length &gt; 0) {
        _remove(arguments[0]);
    } else {
        _removeAll();
    }
    return $.extend(true, {},
    _cache);
};
var searchKeys = function(str) {
    var keys = [];
    var rStr;
    rStr = new RegExp('\\b' + str + '\\b', 'i');
    $.each(_keys,
    function(i, e) {
        if (e.match(rStr)) {
            keys.push(e);
        }
    });
    return keys;
};
var get = function(key) {
    var val;
    if (_cache[key] !== undefined) {
        if ((_cache[key]).toString() === "[object Object]") {
            val = $.extend(true, {},
            _cache[key]);
        } else {
            val = _cache[key];
        }
    }
    return val;
};
var getKey = function(opts) {
    return _serialize(opts);
};
var getKeys = function() {
    return _keys;
};
return {
    add: add,
    exists: exists,
    purge: purge,
    searchKeys: searchKeys,
    get: get,
    getKey: getKey,
    getKeys: getKeys
};
</code></pre>

<p>}).call(this);
```</p>

<p>Here are some jasmine tests which explain more features of the cache not covered in this post, and prove that it works!</p>

<p>``` javascript
it("should allow you to build a cache using keys",
function() {</p>

<pre><code>var obj = {
    'foo': 'bar'
};
expect($.cache.exists("foo=bar")).toEqual(false);
expect($.cache.getKey(obj)).toEqual('foo=bar');
expect($.cache.getKey('foo')).toEqual('foo');
expect($.cache.add("foo=bar", obj)).toEqual(obj);
expect($.cache.exists("foo=bar")).toEqual(true);
expect($.cache.get("foo=bar")).toEqual(obj);
expect($.cache.get("bar")).toEqual(undefined);
</code></pre>

<p>});</p>

<p>it("should allow you to empty the cache completely",
function() {</p>

<pre><code>$.cache.purge();
expect($.cache.add("baz", 'baz')).toEqual('baz');
expect($.cache.getKeys().length).toEqual(1);
expect($.cache.purge()).toEqual({});
</code></pre>

<p>});</p>

<p>it("should allow you to empty the cache of just a specific record",
function() {</p>

<pre><code>$.cache.purge();
expect($.cache.add("baz", 'baz')).toEqual('baz');
expect($.cache.add("boff", 'ball')).toEqual('ball');
expect($.cache.getKeys()).toEqual(['baz', 'boff']);
expect($.cache.purge('boff')).toEqual({
    'baz': 'baz'
});
expect($.cache.getKeys()).toEqual(['baz']);
expect($.cache.purge('bozz')).toEqual({
    'baz': 'baz'
});
expect($.cache.getKeys()).toEqual(['baz']);
</code></pre>

<p>});</p>

<p>it("should allow you to search for keys in the cache",
function() {</p>

<pre><code>$.cache.purge();
var obj = {
    'bar': 'baz'
};
$.cache.add('bar=baz', obj);
expect($.cache.getKeys().length).toEqual(1);
expect($.cache.getKeys()).toEqual(["bar=baz"]);
expect($.cache.searchKeys("bar")).toEqual(["bar=baz"]);
expect($.cache.searchKeys("bar=")).toEqual(["bar=baz"]);
expect($.cache.searchKeys("bat")).toEqual([]);
</code></pre>

<p>});
```</p>
]]></content>
  </entry>
  
</feed>
